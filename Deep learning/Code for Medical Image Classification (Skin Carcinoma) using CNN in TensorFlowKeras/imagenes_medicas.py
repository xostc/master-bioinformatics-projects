# -*- coding: utf-8 -*-
"""Imagenes medicas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gSh9gkfb_Iyw2bp4iuIg1Z66i9kt00OQ
"""

from google.colab import files
import os
from PIL import Image
import matplotlib.pyplot as plt
import tensorflow as tf
import zipfile
import os
from PIL import Image
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Cargar archivo ZIP desde tu computadora local
uploaded = files.upload()

# Definir la ruta de extracción
extract_path = '/content/imagenes'

# Descomprimir el archivo ZIP
for filename in uploaded.keys():
    if filename.endswith('.zip'):
        with zipfile.ZipFile(filename, 'r') as zip_ref:
            zip_ref.extractall('/content/imagenes')

# Verifica la estructura después de descomprimir
print("Contenido de /content/imagenes:")
print(os.listdir('/content/imagenes'))

# Si hay subcarpetas, muestra su contenido
for item in os.listdir('/content/imagenes'):
    item_path = os.path.join('/content/imagenes', item)
    if os.path.isdir(item_path):
        print(f"\nContenido de {item_path}:")
        print(os.listdir(item_path))
benignas_dir = '/content/imagenes/dataset/benignas'
malignas_dir = '/content/imagenes/dataset/malignas'

# Verifica la estructura después de descomprimir
print("Contenido de /content/imagenes:")
print(os.listdir(extract_path))  # Muestra el contenido de la carpeta después de descomprimir

# Si hay subcarpetas, muestra su contenido
for item in os.listdir(extract_path):
    item_path = os.path.join(extract_path, item)
    if os.path.isdir(item_path):
        print(f"\nContenido de {item_path}:")
        print(os.listdir(item_path))

# Intentar identificar las carpetas 'benignas' y 'malignas' automáticamente
benignas_dir = None
malignas_dir = None

# Buscar las carpetas 'Benignos' y 'Malignos' en la estructura extraída
for item in os.listdir(extract_path):
    item_path = os.path.join(extract_path, item)
    if os.path.isdir(item_path):
        # Verificar si 'Benignos' y 'Malignos' existen dentro de esta carpeta
        if 'Benignos' in os.listdir(item_path) and 'Malignos' in os.listdir(item_path):
            benignos_dir = os.path.join(item_path, 'Benignos')
            malignos_dir = os.path.join(item_path, 'Malignos')
            break

# Verificar si se encontraron las carpetas
if benignos_dir and malignos_dir:
    print(f"Carpeta 'Benignos' encontrada en: {benignos_dir}")
    print(f"Carpeta 'Malignos' encontrada en: {malignos_dir}")
else:
    print("No se encontraron las carpetas 'Benignos' y 'Malignos' dentro del archivo ZIP.")

import shutil
from sklearn.model_selection import train_test_split

# Definir las rutas a las carpetas de 'Benignos' y 'Malignos'
benignos_dir = '/content/imagenes/Carcinoma de piel/Benignos'
malignos_dir = '/content/imagenes/Carcinoma de piel/Malignos'

# Crear directorios temporales para entrenamiento y validación
train_dir = '/content/imagenes/train'
validation_dir = '/content/imagenes/validation'

# Crear las carpetas para entrenamiento y validación (si no existen)
os.makedirs(os.path.join(train_dir, 'benignos'), exist_ok=True)
os.makedirs(os.path.join(train_dir, 'malignos'), exist_ok=True)
os.makedirs(os.path.join(validation_dir, 'benignos'), exist_ok=True)
os.makedirs(os.path.join(validation_dir, 'malignos'), exist_ok=True)

# Obtener las listas de las imágenes en cada carpeta
benignos_files = [f for f in os.listdir(benignos_dir) if f.endswith(('png', 'jpg', 'jpeg', 'gif'))]
malignos_files = [f for f in os.listdir(malignos_dir) if f.endswith(('png', 'jpg', 'jpeg', 'gif'))]

# Dividir las imágenes entre entrenamiento y validación
benignos_train, benignos_val = train_test_split(benignos_files, test_size=0.2, random_state=42)
malignos_train, malignos_val = train_test_split(malignos_files, test_size=0.2, random_state=42)

# Mover las imágenes a las carpetas correspondientes
def move_images(files, src_dir, dest_dir):
    for file in files:
        shutil.move(os.path.join(src_dir, file), os.path.join(dest_dir, file))

# Mover las imágenes a las carpetas de entrenamiento y validación
move_images(benignos_train, benignos_dir, os.path.join(train_dir, 'benignos'))
move_images(malignos_train, malignos_dir, os.path.join(train_dir, 'malignos'))
move_images(benignos_val, benignos_dir, os.path.join(validation_dir, 'benignos'))
move_images(malignos_val, malignos_dir, os.path.join(validation_dir, 'malignos'))

# Verificar las carpetas de entrenamiento y validación
print(f"\nContenido de {train_dir}:")
print(os.listdir(train_dir))

print(f"\nContenido de {validation_dir}:")
print(os.listdir(validation_dir))

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Preprocesamiento de imágenes con aumentación para entrenamiento
train_datagen = ImageDataGenerator(
    rescale=1./255,  # Normalización de imágenes
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

# Preprocesamiento para las imágenes de validación (sin aumentación)
validation_datagen = ImageDataGenerator(rescale=1./255)

# Crear generadores de imágenes para cargar los datos desde las carpetas
train_generator = train_datagen.flow_from_directory(
    train_dir,  # Directorio de imágenes de entrenamiento
    target_size=(224, 224),  # Redimensionar imágenes
    batch_size=32,  # Tamaño de lotes
    class_mode='binary'  # Tipo de clasificación: binaria (benigno o maligno)
)

validation_generator = validation_datagen.flow_from_directory(
    validation_dir,  # Directorio de imágenes de validación
    target_size=(224, 224),  # Redimensionar imágenes
    batch_size=32,  # Tamaño de lotes
    class_mode='binary'  # Tipo de clasificación: binaria
)

# Construcción de un modelo CNN
model = Sequential()

# Primera capa convolucional
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 3)))
model.add(MaxPooling2D(pool_size=(2, 2)))

# Segunda capa convolucional
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

# Tercera capa convolucional
model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

# Aplanamiento y capas densas
model.add(Flatten())
model.add(Dense(512, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(1, activation='sigmoid'))  # Salida binaria: benigno o maligno

# Compilación del modelo
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Entrenamiento del modelo
history = model.fit(
    train_generator,
    epochs=10,  # Número de épocas de entrenamiento
    validation_data=validation_generator
)

# Guardar el modelo entrenado
model.save('/content/modelo_cancer_piel.h5')


# Evaluar el rendimiento del modelo en el conjunto de validación
loss, accuracy = model.evaluate(validation_generator)
print(f'Pérdida en validación: {loss}')
print(f'Precisión en validación: {accuracy}')

model.save('/content/modelo_cancer_piel.keras')

# Graficar precisión y pérdida durante el entrenamiento
plt.figure(figsize=(12, 5))

# Precisión de entrenamiento y validación
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Entrenamiento')
plt.plot(history.history['val_accuracy'], label='Validación')
plt.title('Precisión')
plt.xlabel('Época')
plt.ylabel('Precisión')
plt.legend()

# Pérdida de entrenamiento y validación
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Entrenamiento')
plt.plot(history.history['val_loss'], label='Validación')
plt.title('Pérdida')
plt.xlabel('Época')
plt.ylabel('Pérdida')
plt.legend()

plt.show()

import matplotlib.pyplot as plt
from tensorflow.keras.utils import load_img, img_to_array
from google.colab import files
import numpy as np

# Subir una nueva imagen desde tu computadora local
print("Sube la imagen que deseas clasificar:")
uploaded = files.upload()

# Verificar que se ha subido un archivo y obtener su nombre
for filename in uploaded.keys():
    img_path = filename  # Usar el nombre del archivo subido como ruta

# Cargar la imagen y procesarla
img = load_img(img_path, target_size=(224, 224))  # Redimensionar a 224x224
img_array = img_to_array(img) / 255.0  # Convertir la imagen a un array y normalizar (0-1)

# Agregar una dimensión extra para que sea compatible con el modelo
img_array = np.expand_dims(img_array, axis=0)

# Hacer una predicción con el modelo
prediction = model.predict(img_array)

# Determinar el resultado
resultado = "Maligna" if prediction[0] > 0.5 else "Benigna"

# Mostrar la imagen con el resultado
plt.imshow(load_img(img_path))  # Mostrar la imagen original
plt.axis('off')  # Quitar los ejes para una vista limpia
plt.title(f"Clasificación: {resultado}")  # Agregar la clasificación como título
plt.show()

# Imprimir el resultado en texto
print(f"La imagen '{filename}' es {resultado}.")

import matplotlib.pyplot as plt
from tensorflow.keras.utils import load_img, img_to_array
from google.colab import files
import numpy as np

# Subir una nueva imagen desde tu computadora local
print("Sube la imagen que deseas clasificar:")
uploaded = files.upload()

# Verificar que se ha subido un archivo y obtener su nombre
for filename in uploaded.keys():
    img_path = filename  # Usar el nombre del archivo subido como ruta

# Cargar la imagen y procesarla
img = load_img(img_path, target_size=(224, 224))  # Redimensionar a 224x224
img_array = img_to_array(img) / 255.0  # Convertir la imagen a un array y normalizar (0-1)

# Agregar una dimensión extra para que sea compatible con el modelo
img_array = np.expand_dims(img_array, axis=0)

# Hacer una predicción con el modelo
prediction = model.predict(img_array)

# Determinar el resultado
resultado = "Maligna" if prediction[0] > 0.5 else "Benigna"

# Mostrar la imagen con el resultado
plt.imshow(load_img(img_path))  # Mostrar la imagen original
plt.axis('off')  # Quitar los ejes para una vista limpia
plt.title(f"Clasificación: {resultado}")  # Agregar la clasificación como título
plt.show()

# Imprimir el resultado en texto
print(f"La imagen '{filename}' es {resultado}.")

import matplotlib.pyplot as plt
from tensorflow.keras.utils import load_img, img_to_array
from google.colab import files
import numpy as np

# Subir una nueva imagen desde tu computadora local
print("Sube la imagen que deseas clasificar:")
uploaded = files.upload()

# Verificar que se ha subido un archivo y obtener su nombre
for filename in uploaded.keys():
    img_path = filename  # Usar el nombre del archivo subido como ruta

# Cargar la imagen y procesarla
img = load_img(img_path, target_size=(224, 224))  # Redimensionar a 224x224
img_array = img_to_array(img) / 255.0  # Convertir la imagen a un array y normalizar (0-1)

# Agregar una dimensión extra para que sea compatible con el modelo
img_array = np.expand_dims(img_array, axis=0)

# Hacer una predicción con el modelo
prediction = model.predict(img_array)

# Determinar el resultado
resultado = "Maligna" if prediction[0] > 0.5 else "Benigna"

# Mostrar la imagen con el resultado
plt.imshow(load_img(img_path))  # Mostrar la imagen original
plt.axis('off')  # Quitar los ejes para una vista limpia
plt.title(f"Clasificación: {resultado}")  # Agregar la clasificación como título
plt.show()

# Imprimir el resultado en texto
print(f"La imagen '{filename}' es {resultado}.")

from google.colab import files

# Descargar el archivo del modelo
files.download('/content/modelo_cancer_piel.keras')

from google.colab import files
from tensorflow.keras.models import load_model

# Sube el archivo del modelo
uploaded = files.upload()

# Cargar el modelo
model = load_model(list(uploaded.keys())[0])  # Carga el primer archivo subido
print("Modelo cargado correctamente.")

!jupyter nbconvert --to html '/content/Imagenes medicas.ipynb'

!jupyter nbconvert --to html "/content/Imagenes medicas.ipynb" && from google.colab import files; files.download("Imagenes medicas.html")